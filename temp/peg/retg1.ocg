
/*
 * Lexer declarations
 */

space = ' ' | tab | cr | lf | eol;

slcomment = '//' * eol;
mlcomment = nest:'/*' * '*/';

ident = _a-zA-Z{_a-zA-Z0-9};
string = "'" * "'" | '"' * '"';

funcspec = {[type:typespec] | [callspec:callspec]}

typespec = pointerspec | basespec | functype;
basespec = (basetype:IDENT | customtype:IDENT) ['[' arrayindex {',' arrayindex} ']'];
functype = 'func' {[typespec] | [callspec]} '('
  [paramtype param {',' [paramtype] param} ')';
arrayindex = quantity/eval:expression | min/eval:expression '..' max/eval:expression;
pointerspec = pointer:'@' (basetype | customtype) ['[' [arrayindex {',' arrayindex}] ']'];

basetype =
  int:'int' | int8:'int8' | int16:'int16' | int32:'int32' | int64:'int64' |
  uint:'uint' | uint8:'uint8' | uint16:'uint16' | uint32:'uint32' | uint64:'uint64' |
  char:'char' | bool:'bool';

callspec = stdcall | cdecl;

/*
 * Parser declarations
 */

/// statement declarations

statement = 
  labeldecl |
  goto |
  break |
  next |
  bind |
  exit |
  if |
  for |
  repeat |
  while |
  FUNCCALL |
  METHODCALL |
  ASSIGNEXPR;

labeldecl = name:IDENT ':';

goto = 'goto' name:IDENT;

break = 'break' name:IDENT;

next = 'next' name:IDENT;

bind = 'bind' '(' objectvar ',' (interfacename | methodname) {',' (interfacename | methodname)} ')';

exit = 'exit' '(' EXPR ')';

if = ifthen | ifblock;
ifthen = 'if' condition:eval:expression 'then' statement;
ifblock = if:'if' condition:eval:expression
  {statement}
  {elseif:'elseif' condition:eval:expression
   {statement}}
  [else
    {statement}]
  'endif';

for = forto | fordownto | forin;
forto = [name:IDENT ':'] 'for' index:VARREF '=' EXPR 'to' EXPR
  {statement}
  'endfor';
fordownto = [name:IDENT ':'] 'for' index:VARREF '=' EXPR 'downto' EXPR
  {statement}
  'endfor';
forin = [name:IDENT ':']'for' index:VARREF 'in' '[' value:eval:expression {',' value:eval:expression} ']'
  {statement}
  'endfor';

repeat = [name:IDENT ':'] 'repeat'
  {statement}
  'when' condition:EXPR;

while = [name:IDENT ':'] 'while' condition:EXPR
  {statement}
  'endwhile';

FUNCCALL = ;
METHODCALL = ;
ASSIGNEXPR = ;

/// Top level declarations

parse = 'program' namespace:IDENT
  {declaration}
  closetypes:eof;

declaration =
  enum |
  union |
  struct |
  type |
  const |
  globalvar |
  import |
  funcdecl |
  func |
  object |
  ctor |
  dtor |
  interface |
  method |
  operator |
  unary |
  main;

enum = 'enum' name;IDENT
  {typespec field:IDENT {',' field:IDENT}}
'end';

union = 'union' name:IDENT
  {typespec field:IDENT {',' field:IDENT}}
'end';

struct = 'struct' name:IDENT
	  {typespec field:IDENT {',' field:IDENT}}
'end';

type = 'type' typespec name:IDENT;

const = 'const' typespec name:IDENT '=' eval:expression;

globalvar = 'var'
  {typespec IDENT {',' IDENT}}
'end';

import = 'import' funcspec name:IDENT '(' [paramtype:typespec param:IDENT {',' [paramtype:typespec] param:IDENT}] ')'
  'from' STRING
  ['as' name:IDENT];

funcdecl = 'funcdecl' funcspec name:IDENT '(' [paramtype:typespec param:IDENT {',' [paramtype:typespec] param:IDENT}] ')';

func = typedfunc | untypedfunc;
typedfunc = 'func' funcspec name:IDENT '(' [paramtype:typespec param:IDENT {',' [paramtype:typespec] param:IDENT}] ')'
  {localvar}
  {statement | return value:EXPR}
  'end';
untypedfunc = 'func' [callspec] name:IDENT '(' [paramtype:typespec param:IDENT {',' [paramtype:typespec] param:IDENT}] ')'
  {localvar}
  {statement | return}
  'end';

object = 'object' name:IDENT
  [inherits object:IDENT {',' object:IDENT}]
  {mutable:'mutable' |
  immutable:'immutable' |
  membertype:typespec member:IDENT {',' member:IDENT}}
  'end';

ctor = 'ctor' object:IDENT '(' ')'
  {statement | return:'return' BOOLEXPR}
  'end';

dtor = 'dtor' object:IDENT '(' ')'
  {statement | return:'return' BOOLEXPR}
  'end';

interface = 'interface' name:IDENT
  ['inherits' interface:IDENT {',' interface:IDENT}]
  {'method' [type:typespec] name:IDENT '(' [paramtype:typespec param:IDENT {',' [paramtype:typespec] param:IDENT}] ')'}
  'end';

method = typedmethod | untypedmethod;
typedfunc = 'method' type:typespec interface:IDENT '.' name:IDENT '(' [paramtype:typespec param:IDENT {',' [paramtype:typespec] param:IDENT}] ')'
  {localvar}
  {statement | return value:EXPR | OBJECTCALL | OBJECTASSIGNEXPR}
  'end';
untypedfunc = 'method' interface:IDENT '.' name:IDENT '(' [paramtype:typespec param:IDENT {',' [paramtype:typespec] param:IDENT}] ')'
  {localvar}
  {statement | return | OBJECTCALL | OBJECTASSIGNEXPR}
  'end';

operator = 'operator' type:typespec op operand:typespec {',' operand:typespec}
  {localvar}
  {statement | OPASSIGNEXPR};
  'end';

unary = 'unary' ((type:typespec unaryop) | (unaryop type:typespec))
  {localvar}
  {statement | UNARYASSIGNEXPR};
  'end';

main = 'run'
  {localvar}
  {statement}
  'end';
